#-------------------------------------------------------------------------------
# Data-generating function
# Function for one simulation iteration
# Function for multiple iterations
# Function for parallelization
# Function for iterating over scenarios
#-------------------------------------------------------------------------------

## Data-generating process 
##------------------------------------------------------------------------------

dgp <- function(k, I2, k_large, dist) {
  
  # Study sizes
  ni <- c(rep(500, k_large), rep(50, k - k_large))
  
  # Average effect
  mu <- -0.3
  
  # Simulate standard errors
  se <- sqrt(stats::rchisq(k, df = 2 * (ni - 1)) * ((ni - 1) * ni)^(-1))
  
  # Compute tau2
  tau2 <- 1 / k * sum(2 / ni) * (I2 / (1 - I2))
  
  # Simulate true effects and compute quantiles from effect distribution
  if (dist  == "LSN") {
    alpha <- - 4
    d <- alpha / sqrt(1 + alpha ^ 2)
    omega <- sqrt(tau2 / (1 - 2 * (d ^ 2) / pi))
    xi <- mu - omega * d * sqrt(2 / pi)
    es <- sn::rsn(k + 10000, xi = xi, omega = omega, alpha = alpha)
    q <- sn::qsn(c(0.5, 0.9, 0.95), xi = xi, omega = omega + .Machine$double.eps, alpha = alpha)
    
  } else if (dist == "N") {
    es <- stats::rnorm(k + 10000, mean = mu, sd = sqrt(tau2))
    q <- stats::qnorm(c(0.5, 0.9, 0.95), mean = mu, sd = sqrt(tau2))
  }
  
  # Simulate effect estimates
  hes <- rnorm(k, es, sqrt(2/ni))
  
  # Return
  return(list(hes = hes, se = se, es = es, q = q))
  
}

## One simulation iteration
##------------------------------------------------------------------------------

onesim <- function(k, I2, k_large, dist) {
  
  # Generate data 
  dt <- dgp(k = k, I2 = I2, k_large = k_large, dist = dist)
  
  # Extract future effects
  tn <- trySim( {dt$es[(k + 1):length(dt$es)]} )
  
  # Fishers weighted skewness for effect estimates
  skhes <- fwskew(dt$hes, dt$se)
  
  # Fishers skewness for effects
  skes <- if (I2 == 0) { 0 } else { fwskew(dt$es[1:k], rep(1, k)) }
  
  # Fit methods
  mm <- metamethods(dt = dt)
  
  # Performance of predictive distributions
  ppd <- performance_pd(mm = mm, tn = tn, dt = dt, k = k)
  
  # Performance of estimators for average effect
  pmu <- performance_mu(mm = mm)
  
  # Return
  r <- c(ppd$picvr, ppd$piwd, ppd$pisk, mm$t,
         ppd$qhts, ppd$qfix, ppd$qsimple, ppd$qfull,
         ppd$crpshts, ppd$crpsfix, ppd$crpssimple, ppd$crpsfull,
         pmu$bias, pmu$sqe,
         pmu$cicvr, pmu$ciwd, pmu$cisk, 
         skhes, skes, trySim( {mm$p.meta1$tau2} ))
  return(r)
}

## Multiple iterations 
##------------------------------------------------------------------------------

simstudy <-  function(k, I2, k_large, dist, niter) {

  # Perform iterations
  res_list <- replicate(niter, trySim({ onesim(
    k = k,
    I2 = I2,
    dist = dist,
    k_large = k_large
  )}, 64), simplify = FALSE)

  # Transform to matrix
  res <- tryCatch(
    do.call(rbind, res_list),
    error = function(e) matrix(NA_real_, nrow = niter, ncol = 64)
  )

  # Factor levels
  fl <- data.frame(k = k, I2 = I2, dist = dist, k_large = k_large)
  
  # Return
  r <- cbind(fl, res)
  colnames(r)[5:68] <- 5:68
  return(r)
}

## Parallelization
##------------------------------------------------------------------------------

parsimstudy <- function(k, I2, k_large, dist, niter) {
  
  # Number of parallelized CPUs
  n_cores <- 200
  
  # Number of iterations per core
  niter_per_cpu <- ceiling(niter/n_cores)
  
  # Construct cluster
  cl = parallel::makeCluster(n_cores)
  
  # Shutdown the cluster on exit
  on.exit(parallel::stopCluster(cl))
  
  # Export functions to cluster
  clusterExport(cl, varlist = c("simstudy", "onesim", "dgp", "coverpi", "coverci", 
                                "ski", "fwskew", "pg", "simcrps", "trySim", "metaclassic",
                                "metamethods", "performance_pd", "performance_mu"))
  
  # Register for parallel processing
  registerDoParallel(cl)
  
  # Parallelized computation
  res <- foreach(core_nr = 1:n_cores,
                 .packages = c("meta", "sn", "metaprediction"),
                 .combine = rbind) %dorng% {
                   simstudy(k = k, 
                            I2 = I2, 
                            k_large = k_large, 
                            dist = dist,
                            niter = niter_per_cpu)
                 }
  
  # Return
  return(res)
}

## Function to iterate over parameter grid
##------------------------------------------------------------------------------

itersim <- function(k, I2, k_large, dist, niter) {
  
  # Factor levels
  paras <- expand.grid(
    k = k,
    I2 = I2,
    dist = dist,
    k_large = k_large
  )
  
  # Iterate over parameter combinations
  for (param in 1:nrow(paras)) {
    
    # Console message
    message(
      "\n[", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "] ",
      "Running Parameter Iteration ", param, " of ", nrow(paras), "\n",
      "Parameters: ",
      paste(names(paras[param, ]), paras[param, ], sep = " = ", collapse = ", ")
    )
    
    # Catch errors
    try({
      res <- parsimstudy(k = paras$k[param],
                         I2 = paras$I2[param],
                         dist = paras$dist[param],
                         k_large = paras$k_large[param],
                         niter = niter)
      
      colnames(res)[5:68] <-
        c(
          "pi.cvr.hts",
          "pi.cvr.nnf",
          "pi.cvr.fix",
          "pi.cvr.simple",
          "pi.cvr.full",
          "pi.w.hts",
          "pi.w.nnf",
          "pi.w.fix",
          "pi.w.simple",
          "pi.w.full",
          "pi.sk.hts",
          "pi.sk.nnf",
          "pi.sk.fix",
          "pi.sk.simple",
          "pi.sk.full",
          "t.hts",
          "t.nnf",
          "t.fix",
          "t.simple",
          "t.full",
          "q05.hts",
          "q01.hts",
          "q005.hts",
          "q05.fix",
          "q01.fix",
          "q005.fix",
          "q05.simple",
          "q01.simple",
          "q005.simple",
          "q05.full",
          "q01.full",
          "q005.full",
          "crps.hts",
          "crps.fix",
          "crps.simple",
          "crps.full",
          "bias.ivw.fix",
          "bias.ivw.random",
          "bias.held.u",
          "bias.held.a",
          "bias.samp",
          "sqe.ivw.fix",
          "sqe.ivw.random",
          "sqe.held.u",
          "seq.held.a",
          "sqe.samp",
          "ci.cvr.r",
          "ci.cvr.hk",
          "ci.cvr.held.u",
          "ci.cvr.held.a",
          "ci.cvr.samp",
          "ci.w.r",
          "ci.w.hk",
          "ci.w.held.u",
          "ci.w.held.a",
          "ci.w.samp",
          "ci.sk.r",
          "ci.sk.hk",
          "ci.sk.held.u",
          "ci.sk.held.a",
          "ci.sk.samp",
          "sk.hes",
          "sk.es",
          "es.tau2"
        )
                         
      saveRDS(res, file = paste0("../results/sr",
                                 paste(gsub("\\.", "", paras[param, ]), collapse = "_"),
                                 ".RDS"))
    })
  }
}

